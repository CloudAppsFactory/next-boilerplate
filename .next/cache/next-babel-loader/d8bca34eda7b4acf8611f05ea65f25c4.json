{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// #region Global Imports\nimport \"isomorphic-unfetch\";\nimport { stringify } from \"query-string\"; // #endregion Global Imports\n// #region Interface Imports\n\n// #endregion Interface Imports\nconst BaseUrl = `${process.env.NEXT_PUBLIC_API_URL}/api`;\nexport const Http = {\n  Request: async (methodType, url, params, payload) => {\n    return new Promise((resolve, reject) => {\n      const query = params ? `?${stringify(_objectSpread(_objectSpread({}, params), {}, {\n        api_key: process.env.NEXT_PUBLIC_API_KEY\n      }))}` : \"\";\n      fetch(`${BaseUrl}${url}${query}`, {\n        body: JSON.stringify(payload),\n        cache: \"no-cache\",\n        headers: {\n          \"content-type\": \"application/json\"\n        },\n        method: `${methodType}`\n      }).then(async response => {\n        if (response.status === 200) {\n          return response.json().then(resolve);\n        }\n\n        return reject(response);\n      }).catch(e => {\n        reject(e);\n      });\n    });\n  }\n};","map":{"version":3,"sources":["F:/MY_GIT/next-boilerplate/src/Services/API/Http/index.ts"],"names":["stringify","BaseUrl","process","env","NEXT_PUBLIC_API_URL","Http","Request","methodType","url","params","payload","Promise","resolve","reject","query","api_key","NEXT_PUBLIC_API_KEY","fetch","body","JSON","cache","headers","method","then","response","status","json","catch","e"],"mappings":";;;;;;AAAA;AACA,OAAO,oBAAP;AACA,SAASA,SAAT,QAA0B,cAA1B,C,CACA;AAEA;;AAEA;AAEA,MAAMC,OAAO,GAAI,GAAEC,OAAO,CAACC,GAAR,CAAYC,mBAAoB,MAAnD;AACA,OAAO,MAAMC,IAAI,GAAG;AAChBC,EAAAA,OAAO,EAAE,OACLC,UADK,EAELC,GAFK,EAGLC,MAHK,EAILC,OAJK,KAKQ;AACb,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpC,YAAMC,KAAK,GAAGL,MAAM,GACb,IAAGT,SAAS,iCACNS,MADM;AAETM,QAAAA,OAAO,EAAEb,OAAO,CAACC,GAAR,CAAYa;AAFZ,SAGV,EAJW,GAKd,EALN;AAOAC,MAAAA,KAAK,CAAE,GAAEhB,OAAQ,GAAEO,GAAI,GAAEM,KAAM,EAA1B,EAA6B;AAC9BI,QAAAA,IAAI,EAAEC,IAAI,CAACnB,SAAL,CAAeU,OAAf,CADwB;AAE9BU,QAAAA,KAAK,EAAE,UAFuB;AAG9BC,QAAAA,OAAO,EAAE;AACL,0BAAgB;AADX,SAHqB;AAM9BC,QAAAA,MAAM,EAAG,GAAEf,UAAW;AANQ,OAA7B,CAAL,CAQKgB,IARL,CAQU,MAAMC,QAAN,IAAkB;AACpB,YAAIA,QAAQ,CAACC,MAAT,KAAoB,GAAxB,EAA6B;AACzB,iBAAOD,QAAQ,CAACE,IAAT,GAAgBH,IAAhB,CAAqBX,OAArB,CAAP;AACH;;AACD,eAAOC,MAAM,CAACW,QAAD,CAAb;AACH,OAbL,EAcKG,KAdL,CAcWC,CAAC,IAAI;AACRf,QAAAA,MAAM,CAACe,CAAD,CAAN;AACH,OAhBL;AAiBH,KAzBM,CAAP;AA0BH;AAjCe,CAAb","sourcesContent":["// #region Global Imports\r\nimport \"isomorphic-unfetch\";\r\nimport { stringify } from \"query-string\";\r\n// #endregion Global Imports\r\n\r\n// #region Interface Imports\r\nimport { HttpModel } from \"@Interfaces\";\r\n// #endregion Interface Imports\r\n\r\nconst BaseUrl = `${process.env.NEXT_PUBLIC_API_URL}/api`;\r\nexport const Http = {\r\n    Request: async <A>(\r\n        methodType: string,\r\n        url: string,\r\n        params?: HttpModel.IRequestQueryPayload,\r\n        payload?: HttpModel.IRequestPayload\r\n    ): Promise<A> => {\r\n        return new Promise((resolve, reject) => {\r\n            const query = params\r\n                ? `?${stringify({\r\n                      ...params,\r\n                      api_key: process.env.NEXT_PUBLIC_API_KEY,\r\n                  })}`\r\n                : \"\";\r\n\r\n            fetch(`${BaseUrl}${url}${query}`, {\r\n                body: JSON.stringify(payload),\r\n                cache: \"no-cache\",\r\n                headers: {\r\n                    \"content-type\": \"application/json\",\r\n                },\r\n                method: `${methodType}`,\r\n            })\r\n                .then(async response => {\r\n                    if (response.status === 200) {\r\n                        return response.json().then(resolve);\r\n                    }\r\n                    return reject(response);\r\n                })\r\n                .catch(e => {\r\n                    reject(e);\r\n                });\r\n        });\r\n    },\r\n};\r\n"]},"metadata":{},"sourceType":"module"}